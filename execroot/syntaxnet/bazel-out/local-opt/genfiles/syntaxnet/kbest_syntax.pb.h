// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: syntaxnet/kbest_syntax.proto

#ifndef PROTOBUF_syntaxnet_2fkbest_5fsyntax_2eproto__INCLUDED
#define PROTOBUF_syntaxnet_2fkbest_5fsyntax_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "syntaxnet/sentence.pb.h"
// @@protoc_insertion_point(includes)
namespace syntaxnet {
class AlternativeTokenAnalysis;
class AlternativeTokenAnalysisDefaultTypeInternal;
extern AlternativeTokenAnalysisDefaultTypeInternal _AlternativeTokenAnalysis_default_instance_;
class KBestSyntaxAnalyses;
class KBestSyntaxAnalysesDefaultTypeInternal;
extern KBestSyntaxAnalysesDefaultTypeInternal _KBestSyntaxAnalyses_default_instance_;
class KBestSyntaxAnalysesForSentence;
class KBestSyntaxAnalysesForSentenceDefaultTypeInternal;
extern KBestSyntaxAnalysesForSentenceDefaultTypeInternal _KBestSyntaxAnalysesForSentence_default_instance_;
class KBestSyntaxAnalysesForToken;
class KBestSyntaxAnalysesForTokenDefaultTypeInternal;
extern KBestSyntaxAnalysesForTokenDefaultTypeInternal _KBestSyntaxAnalysesForToken_default_instance_;
class Sentence;
class SentenceDefaultTypeInternal;
extern SentenceDefaultTypeInternal _Sentence_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class TokenMorphology;
class TokenMorphologyDefaultTypeInternal;
extern TokenMorphologyDefaultTypeInternal _TokenMorphology_default_instance_;
class TokenMorphology_Attribute;
class TokenMorphology_AttributeDefaultTypeInternal;
extern TokenMorphology_AttributeDefaultTypeInternal _TokenMorphology_Attribute_default_instance_;
}  // namespace syntaxnet

namespace syntaxnet {

namespace protobuf_syntaxnet_2fkbest_5fsyntax_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_syntaxnet_2fkbest_5fsyntax_2eproto

// ===================================================================

class KBestSyntaxAnalyses : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:syntaxnet.KBestSyntaxAnalyses) */ {
 public:
  KBestSyntaxAnalyses();
  virtual ~KBestSyntaxAnalyses();

  KBestSyntaxAnalyses(const KBestSyntaxAnalyses& from);

  inline KBestSyntaxAnalyses& operator=(const KBestSyntaxAnalyses& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KBestSyntaxAnalyses& default_instance();

  static inline const KBestSyntaxAnalyses* internal_default_instance() {
    return reinterpret_cast<const KBestSyntaxAnalyses*>(
               &_KBestSyntaxAnalyses_default_instance_);
  }

  void Swap(KBestSyntaxAnalyses* other);

  // implements Message ----------------------------------------------

  inline KBestSyntaxAnalyses* New() const PROTOBUF_FINAL { return New(NULL); }

  KBestSyntaxAnalyses* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KBestSyntaxAnalyses& from);
  void MergeFrom(const KBestSyntaxAnalyses& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KBestSyntaxAnalyses* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .syntaxnet.KBestSyntaxAnalysesForSentence sentence = 1;
  int sentence_size() const;
  void clear_sentence();
  static const int kSentenceFieldNumber = 1;
  const ::syntaxnet::KBestSyntaxAnalysesForSentence& sentence(int index) const;
  ::syntaxnet::KBestSyntaxAnalysesForSentence* mutable_sentence(int index);
  ::syntaxnet::KBestSyntaxAnalysesForSentence* add_sentence();
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForSentence >*
      mutable_sentence();
  const ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForSentence >&
      sentence() const;

  // repeated .syntaxnet.KBestSyntaxAnalysesForToken token = 2;
  int token_size() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::syntaxnet::KBestSyntaxAnalysesForToken& token(int index) const;
  ::syntaxnet::KBestSyntaxAnalysesForToken* mutable_token(int index);
  ::syntaxnet::KBestSyntaxAnalysesForToken* add_token();
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForToken >*
      mutable_token();
  const ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForToken >&
      token() const;

  static const int kExtensionFieldNumber = 60366242;
  static ::google::protobuf::internal::ExtensionIdentifier< ::syntaxnet::Sentence,
      ::google::protobuf::internal::MessageTypeTraits< ::syntaxnet::KBestSyntaxAnalyses >, 11, false >
    extension;
  // @@protoc_insertion_point(class_scope:syntaxnet.KBestSyntaxAnalyses)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForSentence > sentence_;
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForToken > token_;
  friend struct  protobuf_syntaxnet_2fkbest_5fsyntax_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KBestSyntaxAnalysesForSentence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:syntaxnet.KBestSyntaxAnalysesForSentence) */ {
 public:
  KBestSyntaxAnalysesForSentence();
  virtual ~KBestSyntaxAnalysesForSentence();

  KBestSyntaxAnalysesForSentence(const KBestSyntaxAnalysesForSentence& from);

  inline KBestSyntaxAnalysesForSentence& operator=(const KBestSyntaxAnalysesForSentence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KBestSyntaxAnalysesForSentence& default_instance();

  static inline const KBestSyntaxAnalysesForSentence* internal_default_instance() {
    return reinterpret_cast<const KBestSyntaxAnalysesForSentence*>(
               &_KBestSyntaxAnalysesForSentence_default_instance_);
  }

  void Swap(KBestSyntaxAnalysesForSentence* other);

  // implements Message ----------------------------------------------

  inline KBestSyntaxAnalysesForSentence* New() const PROTOBUF_FINAL { return New(NULL); }

  KBestSyntaxAnalysesForSentence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KBestSyntaxAnalysesForSentence& from);
  void MergeFrom(const KBestSyntaxAnalysesForSentence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KBestSyntaxAnalysesForSentence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .syntaxnet.AlternativeTokenAnalysis token_analysis = 3;
  int token_analysis_size() const;
  void clear_token_analysis();
  static const int kTokenAnalysisFieldNumber = 3;
  const ::syntaxnet::AlternativeTokenAnalysis& token_analysis(int index) const;
  ::syntaxnet::AlternativeTokenAnalysis* mutable_token_analysis(int index);
  ::syntaxnet::AlternativeTokenAnalysis* add_token_analysis();
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >*
      mutable_token_analysis();
  const ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >&
      token_analysis() const;

  // optional int32 start = 1 [default = -1];
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 2 [default = -1];
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:syntaxnet.KBestSyntaxAnalysesForSentence)
 private:
  void set_has_start();
  void clear_has_start();
  void set_has_end();
  void clear_has_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis > token_analysis_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  friend struct  protobuf_syntaxnet_2fkbest_5fsyntax_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KBestSyntaxAnalysesForToken : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:syntaxnet.KBestSyntaxAnalysesForToken) */ {
 public:
  KBestSyntaxAnalysesForToken();
  virtual ~KBestSyntaxAnalysesForToken();

  KBestSyntaxAnalysesForToken(const KBestSyntaxAnalysesForToken& from);

  inline KBestSyntaxAnalysesForToken& operator=(const KBestSyntaxAnalysesForToken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KBestSyntaxAnalysesForToken& default_instance();

  static inline const KBestSyntaxAnalysesForToken* internal_default_instance() {
    return reinterpret_cast<const KBestSyntaxAnalysesForToken*>(
               &_KBestSyntaxAnalysesForToken_default_instance_);
  }

  void Swap(KBestSyntaxAnalysesForToken* other);

  // implements Message ----------------------------------------------

  inline KBestSyntaxAnalysesForToken* New() const PROTOBUF_FINAL { return New(NULL); }

  KBestSyntaxAnalysesForToken* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KBestSyntaxAnalysesForToken& from);
  void MergeFrom(const KBestSyntaxAnalysesForToken& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KBestSyntaxAnalysesForToken* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .syntaxnet.AlternativeTokenAnalysis token_analysis = 3;
  int token_analysis_size() const;
  void clear_token_analysis();
  static const int kTokenAnalysisFieldNumber = 3;
  const ::syntaxnet::AlternativeTokenAnalysis& token_analysis(int index) const;
  ::syntaxnet::AlternativeTokenAnalysis* mutable_token_analysis(int index);
  ::syntaxnet::AlternativeTokenAnalysis* add_token_analysis();
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >*
      mutable_token_analysis();
  const ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >&
      token_analysis() const;

  // @@protoc_insertion_point(class_scope:syntaxnet.KBestSyntaxAnalysesForToken)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis > token_analysis_;
  friend struct  protobuf_syntaxnet_2fkbest_5fsyntax_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AlternativeTokenAnalysis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:syntaxnet.AlternativeTokenAnalysis) */ {
 public:
  AlternativeTokenAnalysis();
  virtual ~AlternativeTokenAnalysis();

  AlternativeTokenAnalysis(const AlternativeTokenAnalysis& from);

  inline AlternativeTokenAnalysis& operator=(const AlternativeTokenAnalysis& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AlternativeTokenAnalysis& default_instance();

  static inline const AlternativeTokenAnalysis* internal_default_instance() {
    return reinterpret_cast<const AlternativeTokenAnalysis*>(
               &_AlternativeTokenAnalysis_default_instance_);
  }

  void Swap(AlternativeTokenAnalysis* other);

  // implements Message ----------------------------------------------

  inline AlternativeTokenAnalysis* New() const PROTOBUF_FINAL { return New(NULL); }

  AlternativeTokenAnalysis* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AlternativeTokenAnalysis& from);
  void MergeFrom(const AlternativeTokenAnalysis& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AlternativeTokenAnalysis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 head = 1;
  int head_size() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  ::google::protobuf::int32 head(int index) const;
  void set_head(int index, ::google::protobuf::int32 value);
  void add_head(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      head() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_head();

  // repeated string tag = 2;
  int tag_size() const;
  void clear_tag();
  static const int kTagFieldNumber = 2;
  const ::std::string& tag(int index) const;
  ::std::string* mutable_tag(int index);
  void set_tag(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tag(int index, ::std::string&& value);
  #endif
  void set_tag(int index, const char* value);
  void set_tag(int index, const char* value, size_t size);
  ::std::string* add_tag();
  void add_tag(const ::std::string& value);
  #if LANG_CXX11
  void add_tag(::std::string&& value);
  #endif
  void add_tag(const char* value);
  void add_tag(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tag() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tag();

  // repeated string category = 3;
  int category_size() const;
  void clear_category();
  static const int kCategoryFieldNumber = 3;
  const ::std::string& category(int index) const;
  ::std::string* mutable_category(int index);
  void set_category(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_category(int index, ::std::string&& value);
  #endif
  void set_category(int index, const char* value);
  void set_category(int index, const char* value, size_t size);
  ::std::string* add_category();
  void add_category(const ::std::string& value);
  #if LANG_CXX11
  void add_category(::std::string&& value);
  #endif
  void add_category(const char* value);
  void add_category(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& category() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_category();

  // repeated string label = 4;
  int label_size() const;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label(int index) const;
  ::std::string* mutable_label(int index);
  void set_label(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_label(int index, ::std::string&& value);
  #endif
  void set_label(int index, const char* value);
  void set_label(int index, const char* value, size_t size);
  ::std::string* add_label();
  void add_label(const ::std::string& value);
  #if LANG_CXX11
  void add_label(::std::string&& value);
  #endif
  void add_label(const char* value);
  void add_label(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& label() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_label();

  // optional double score = 5;
  bool has_score() const;
  void clear_score();
  static const int kScoreFieldNumber = 5;
  double score() const;
  void set_score(double value);

  // @@protoc_insertion_point(class_scope:syntaxnet.AlternativeTokenAnalysis)
 private:
  void set_has_score();
  void clear_has_score();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > head_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tag_;
  ::google::protobuf::RepeatedPtrField< ::std::string> category_;
  ::google::protobuf::RepeatedPtrField< ::std::string> label_;
  double score_;
  friend struct  protobuf_syntaxnet_2fkbest_5fsyntax_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// KBestSyntaxAnalyses

// repeated .syntaxnet.KBestSyntaxAnalysesForSentence sentence = 1;
inline int KBestSyntaxAnalyses::sentence_size() const {
  return sentence_.size();
}
inline void KBestSyntaxAnalyses::clear_sentence() {
  sentence_.Clear();
}
inline const ::syntaxnet::KBestSyntaxAnalysesForSentence& KBestSyntaxAnalyses::sentence(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalyses.sentence)
  return sentence_.Get(index);
}
inline ::syntaxnet::KBestSyntaxAnalysesForSentence* KBestSyntaxAnalyses::mutable_sentence(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.KBestSyntaxAnalyses.sentence)
  return sentence_.Mutable(index);
}
inline ::syntaxnet::KBestSyntaxAnalysesForSentence* KBestSyntaxAnalyses::add_sentence() {
  // @@protoc_insertion_point(field_add:syntaxnet.KBestSyntaxAnalyses.sentence)
  return sentence_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForSentence >*
KBestSyntaxAnalyses::mutable_sentence() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.KBestSyntaxAnalyses.sentence)
  return &sentence_;
}
inline const ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForSentence >&
KBestSyntaxAnalyses::sentence() const {
  // @@protoc_insertion_point(field_list:syntaxnet.KBestSyntaxAnalyses.sentence)
  return sentence_;
}

// repeated .syntaxnet.KBestSyntaxAnalysesForToken token = 2;
inline int KBestSyntaxAnalyses::token_size() const {
  return token_.size();
}
inline void KBestSyntaxAnalyses::clear_token() {
  token_.Clear();
}
inline const ::syntaxnet::KBestSyntaxAnalysesForToken& KBestSyntaxAnalyses::token(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalyses.token)
  return token_.Get(index);
}
inline ::syntaxnet::KBestSyntaxAnalysesForToken* KBestSyntaxAnalyses::mutable_token(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.KBestSyntaxAnalyses.token)
  return token_.Mutable(index);
}
inline ::syntaxnet::KBestSyntaxAnalysesForToken* KBestSyntaxAnalyses::add_token() {
  // @@protoc_insertion_point(field_add:syntaxnet.KBestSyntaxAnalyses.token)
  return token_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForToken >*
KBestSyntaxAnalyses::mutable_token() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.KBestSyntaxAnalyses.token)
  return &token_;
}
inline const ::google::protobuf::RepeatedPtrField< ::syntaxnet::KBestSyntaxAnalysesForToken >&
KBestSyntaxAnalyses::token() const {
  // @@protoc_insertion_point(field_list:syntaxnet.KBestSyntaxAnalyses.token)
  return token_;
}

// -------------------------------------------------------------------

// KBestSyntaxAnalysesForSentence

// optional int32 start = 1 [default = -1];
inline bool KBestSyntaxAnalysesForSentence::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KBestSyntaxAnalysesForSentence::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KBestSyntaxAnalysesForSentence::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KBestSyntaxAnalysesForSentence::clear_start() {
  start_ = -1;
  clear_has_start();
}
inline ::google::protobuf::int32 KBestSyntaxAnalysesForSentence::start() const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalysesForSentence.start)
  return start_;
}
inline void KBestSyntaxAnalysesForSentence::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:syntaxnet.KBestSyntaxAnalysesForSentence.start)
}

// optional int32 end = 2 [default = -1];
inline bool KBestSyntaxAnalysesForSentence::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KBestSyntaxAnalysesForSentence::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KBestSyntaxAnalysesForSentence::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KBestSyntaxAnalysesForSentence::clear_end() {
  end_ = -1;
  clear_has_end();
}
inline ::google::protobuf::int32 KBestSyntaxAnalysesForSentence::end() const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalysesForSentence.end)
  return end_;
}
inline void KBestSyntaxAnalysesForSentence::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:syntaxnet.KBestSyntaxAnalysesForSentence.end)
}

// repeated .syntaxnet.AlternativeTokenAnalysis token_analysis = 3;
inline int KBestSyntaxAnalysesForSentence::token_analysis_size() const {
  return token_analysis_.size();
}
inline void KBestSyntaxAnalysesForSentence::clear_token_analysis() {
  token_analysis_.Clear();
}
inline const ::syntaxnet::AlternativeTokenAnalysis& KBestSyntaxAnalysesForSentence::token_analysis(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalysesForSentence.token_analysis)
  return token_analysis_.Get(index);
}
inline ::syntaxnet::AlternativeTokenAnalysis* KBestSyntaxAnalysesForSentence::mutable_token_analysis(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.KBestSyntaxAnalysesForSentence.token_analysis)
  return token_analysis_.Mutable(index);
}
inline ::syntaxnet::AlternativeTokenAnalysis* KBestSyntaxAnalysesForSentence::add_token_analysis() {
  // @@protoc_insertion_point(field_add:syntaxnet.KBestSyntaxAnalysesForSentence.token_analysis)
  return token_analysis_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >*
KBestSyntaxAnalysesForSentence::mutable_token_analysis() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.KBestSyntaxAnalysesForSentence.token_analysis)
  return &token_analysis_;
}
inline const ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >&
KBestSyntaxAnalysesForSentence::token_analysis() const {
  // @@protoc_insertion_point(field_list:syntaxnet.KBestSyntaxAnalysesForSentence.token_analysis)
  return token_analysis_;
}

// -------------------------------------------------------------------

// KBestSyntaxAnalysesForToken

// repeated .syntaxnet.AlternativeTokenAnalysis token_analysis = 3;
inline int KBestSyntaxAnalysesForToken::token_analysis_size() const {
  return token_analysis_.size();
}
inline void KBestSyntaxAnalysesForToken::clear_token_analysis() {
  token_analysis_.Clear();
}
inline const ::syntaxnet::AlternativeTokenAnalysis& KBestSyntaxAnalysesForToken::token_analysis(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.KBestSyntaxAnalysesForToken.token_analysis)
  return token_analysis_.Get(index);
}
inline ::syntaxnet::AlternativeTokenAnalysis* KBestSyntaxAnalysesForToken::mutable_token_analysis(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.KBestSyntaxAnalysesForToken.token_analysis)
  return token_analysis_.Mutable(index);
}
inline ::syntaxnet::AlternativeTokenAnalysis* KBestSyntaxAnalysesForToken::add_token_analysis() {
  // @@protoc_insertion_point(field_add:syntaxnet.KBestSyntaxAnalysesForToken.token_analysis)
  return token_analysis_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >*
KBestSyntaxAnalysesForToken::mutable_token_analysis() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.KBestSyntaxAnalysesForToken.token_analysis)
  return &token_analysis_;
}
inline const ::google::protobuf::RepeatedPtrField< ::syntaxnet::AlternativeTokenAnalysis >&
KBestSyntaxAnalysesForToken::token_analysis() const {
  // @@protoc_insertion_point(field_list:syntaxnet.KBestSyntaxAnalysesForToken.token_analysis)
  return token_analysis_;
}

// -------------------------------------------------------------------

// AlternativeTokenAnalysis

// repeated int32 head = 1;
inline int AlternativeTokenAnalysis::head_size() const {
  return head_.size();
}
inline void AlternativeTokenAnalysis::clear_head() {
  head_.Clear();
}
inline ::google::protobuf::int32 AlternativeTokenAnalysis::head(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.AlternativeTokenAnalysis.head)
  return head_.Get(index);
}
inline void AlternativeTokenAnalysis::set_head(int index, ::google::protobuf::int32 value) {
  head_.Set(index, value);
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.head)
}
inline void AlternativeTokenAnalysis::add_head(::google::protobuf::int32 value) {
  head_.Add(value);
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.head)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
AlternativeTokenAnalysis::head() const {
  // @@protoc_insertion_point(field_list:syntaxnet.AlternativeTokenAnalysis.head)
  return head_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
AlternativeTokenAnalysis::mutable_head() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.AlternativeTokenAnalysis.head)
  return &head_;
}

// repeated string tag = 2;
inline int AlternativeTokenAnalysis::tag_size() const {
  return tag_.size();
}
inline void AlternativeTokenAnalysis::clear_tag() {
  tag_.Clear();
}
inline const ::std::string& AlternativeTokenAnalysis::tag(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.AlternativeTokenAnalysis.tag)
  return tag_.Get(index);
}
inline ::std::string* AlternativeTokenAnalysis::mutable_tag(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.AlternativeTokenAnalysis.tag)
  return tag_.Mutable(index);
}
inline void AlternativeTokenAnalysis::set_tag(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.tag)
  tag_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::set_tag(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.tag)
  tag_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AlternativeTokenAnalysis::set_tag(int index, const char* value) {
  tag_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:syntaxnet.AlternativeTokenAnalysis.tag)
}
inline void AlternativeTokenAnalysis::set_tag(int index, const char* value, size_t size) {
  tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:syntaxnet.AlternativeTokenAnalysis.tag)
}
inline ::std::string* AlternativeTokenAnalysis::add_tag() {
  // @@protoc_insertion_point(field_add_mutable:syntaxnet.AlternativeTokenAnalysis.tag)
  return tag_.Add();
}
inline void AlternativeTokenAnalysis::add_tag(const ::std::string& value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.tag)
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::add_tag(::std::string&& value) {
  tag_.Add()->assign(std::move(value));
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.tag)
}
#endif
inline void AlternativeTokenAnalysis::add_tag(const char* value) {
  tag_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:syntaxnet.AlternativeTokenAnalysis.tag)
}
inline void AlternativeTokenAnalysis::add_tag(const char* value, size_t size) {
  tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:syntaxnet.AlternativeTokenAnalysis.tag)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AlternativeTokenAnalysis::tag() const {
  // @@protoc_insertion_point(field_list:syntaxnet.AlternativeTokenAnalysis.tag)
  return tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AlternativeTokenAnalysis::mutable_tag() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.AlternativeTokenAnalysis.tag)
  return &tag_;
}

// repeated string category = 3;
inline int AlternativeTokenAnalysis::category_size() const {
  return category_.size();
}
inline void AlternativeTokenAnalysis::clear_category() {
  category_.Clear();
}
inline const ::std::string& AlternativeTokenAnalysis::category(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.AlternativeTokenAnalysis.category)
  return category_.Get(index);
}
inline ::std::string* AlternativeTokenAnalysis::mutable_category(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.AlternativeTokenAnalysis.category)
  return category_.Mutable(index);
}
inline void AlternativeTokenAnalysis::set_category(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.category)
  category_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::set_category(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.category)
  category_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AlternativeTokenAnalysis::set_category(int index, const char* value) {
  category_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:syntaxnet.AlternativeTokenAnalysis.category)
}
inline void AlternativeTokenAnalysis::set_category(int index, const char* value, size_t size) {
  category_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:syntaxnet.AlternativeTokenAnalysis.category)
}
inline ::std::string* AlternativeTokenAnalysis::add_category() {
  // @@protoc_insertion_point(field_add_mutable:syntaxnet.AlternativeTokenAnalysis.category)
  return category_.Add();
}
inline void AlternativeTokenAnalysis::add_category(const ::std::string& value) {
  category_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.category)
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::add_category(::std::string&& value) {
  category_.Add()->assign(std::move(value));
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.category)
}
#endif
inline void AlternativeTokenAnalysis::add_category(const char* value) {
  category_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:syntaxnet.AlternativeTokenAnalysis.category)
}
inline void AlternativeTokenAnalysis::add_category(const char* value, size_t size) {
  category_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:syntaxnet.AlternativeTokenAnalysis.category)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AlternativeTokenAnalysis::category() const {
  // @@protoc_insertion_point(field_list:syntaxnet.AlternativeTokenAnalysis.category)
  return category_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AlternativeTokenAnalysis::mutable_category() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.AlternativeTokenAnalysis.category)
  return &category_;
}

// repeated string label = 4;
inline int AlternativeTokenAnalysis::label_size() const {
  return label_.size();
}
inline void AlternativeTokenAnalysis::clear_label() {
  label_.Clear();
}
inline const ::std::string& AlternativeTokenAnalysis::label(int index) const {
  // @@protoc_insertion_point(field_get:syntaxnet.AlternativeTokenAnalysis.label)
  return label_.Get(index);
}
inline ::std::string* AlternativeTokenAnalysis::mutable_label(int index) {
  // @@protoc_insertion_point(field_mutable:syntaxnet.AlternativeTokenAnalysis.label)
  return label_.Mutable(index);
}
inline void AlternativeTokenAnalysis::set_label(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.label)
  label_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::set_label(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.label)
  label_.Mutable(index)->assign(std::move(value));
}
#endif
inline void AlternativeTokenAnalysis::set_label(int index, const char* value) {
  label_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:syntaxnet.AlternativeTokenAnalysis.label)
}
inline void AlternativeTokenAnalysis::set_label(int index, const char* value, size_t size) {
  label_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:syntaxnet.AlternativeTokenAnalysis.label)
}
inline ::std::string* AlternativeTokenAnalysis::add_label() {
  // @@protoc_insertion_point(field_add_mutable:syntaxnet.AlternativeTokenAnalysis.label)
  return label_.Add();
}
inline void AlternativeTokenAnalysis::add_label(const ::std::string& value) {
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.label)
}
#if LANG_CXX11
inline void AlternativeTokenAnalysis::add_label(::std::string&& value) {
  label_.Add()->assign(std::move(value));
  // @@protoc_insertion_point(field_add:syntaxnet.AlternativeTokenAnalysis.label)
}
#endif
inline void AlternativeTokenAnalysis::add_label(const char* value) {
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:syntaxnet.AlternativeTokenAnalysis.label)
}
inline void AlternativeTokenAnalysis::add_label(const char* value, size_t size) {
  label_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:syntaxnet.AlternativeTokenAnalysis.label)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AlternativeTokenAnalysis::label() const {
  // @@protoc_insertion_point(field_list:syntaxnet.AlternativeTokenAnalysis.label)
  return label_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AlternativeTokenAnalysis::mutable_label() {
  // @@protoc_insertion_point(field_mutable_list:syntaxnet.AlternativeTokenAnalysis.label)
  return &label_;
}

// optional double score = 5;
inline bool AlternativeTokenAnalysis::has_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlternativeTokenAnalysis::set_has_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlternativeTokenAnalysis::clear_has_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlternativeTokenAnalysis::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double AlternativeTokenAnalysis::score() const {
  // @@protoc_insertion_point(field_get:syntaxnet.AlternativeTokenAnalysis.score)
  return score_;
}
inline void AlternativeTokenAnalysis::set_score(double value) {
  set_has_score();
  score_ = value;
  // @@protoc_insertion_point(field_set:syntaxnet.AlternativeTokenAnalysis.score)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace syntaxnet

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_syntaxnet_2fkbest_5fsyntax_2eproto__INCLUDED
